懂其所以；不可以不求甚解
-  Promise

动手实现简易版的Promise后，[Promise是一个容器，包含着很多未来才会执行的事件]
```javascript
class MyPromise {
  constructor(callback) {
    // 处理返回成功的逻辑
    let value = null
    let isSuccess = null
    const arr = []
    this.then = (thenFn) => {
      if (isSuccess === true) {
        arr.push(thenFn(arr.length === 0 ? value : arr[arr.length - 1]))
      }
      return this
    }
    // 处理返回失败的逻辑
    this.catch = (catchFn) => {
      if (isSuccess === false) {
        catchFn(value)
      }
      return this
    }
    function resolve(data) {
      isSuccess = true
      value = data
    }
    function reject(data) {
      isSuccess = false
      value = data
    }
    callback(resolve, reject)
  }
}
```

- prototype、__proto__
```
prototype: 实例共享的属性和方法
__proto__只要是对象就有该属性；prototype函数独有；__proto__指向通过构造函数生成自身的构造函数的prototype
construcotr 是 prototype的一个属性 指向构造函数本身
```

- new 的由来
  - 返回了一个对象，对象的__proto__指向生成该对象函数的prototype
```javascript
// 声明一个英雄
const hero = {
  id: 1,
  种类: '法师',
  生命值: 1000,
  攻击力: 60,
  法强: 200,
  行走: function() {/* 行走的代码 */},
  攻击: function() {/* 攻击的代码 */}
}

// 声明一百个英雄
const heros = []
for (let i = 0; i < 100; i++) {
  heros.push({
    id: i + 1,
    种类: '法师',
    生命值: 1000,
    攻击力: 60,
    法强: 200,
    行走: function() {/* 行走的代码 */},
    攻击: function() {/* 攻击的代码 */}
  })
}
// 质疑声也随之而来，100个英雄意味着占了100份单个英雄的内存，但是呢除了id, 其他的都可以共享, 非常浪费内存

// 解决方式
// 先声明英雄的原型，（可共享的放在这里面）
const hero.原型 = {
  种类: '法师',
  生命值: 1000,
  攻击力: 60,
  法强: 200,
  行走: function() {/* 行走的代码 */},
  攻击: function() {/* 攻击的代码 */}
}
for (let i = 0; i < 100; i++) {
  cont tmpHero = {}
  tmpHero.__proto__ = hero.原型 // js引擎读属性或方法时，会沿着这个线去读 hero.XXX，没找到hero.__proto__.XXX, 找不到则一直找下去，直到proto为null
  tmpHero.id = i + 1
  heros.push(tmpHero)
}
// 嗯，可以解决内存浪费的问题，但是呢！！！在两处声明一个英雄对象，维护层面和代码可读性非常差

// 解决方式
function hero (id) {
  const 临时对象 = {}
  临时对象.__proto__ = hero.原型
  临时对象.id = id
  return 临时对象
}
for(let i = 0; i < 100; i++) {
  heros.push(hero(i + 1))
}
// 嗯，解决了两处代码声明英雄对象的问题

// 这时候js之父为了解决这个问题；发明了new关键词
function hero2(id) {
  // const 临时对象 = {} 不用写
  // 临时对象.__proto__ = hero.原型 // 不用写，而且统一将公用方法（原型）声明成prototype
  this.id =  id
  // 临时对象.id = id // this.id = id 代替
  // return 临时对象 // 不用写
}
new hero2() 相当于 hero()
// 对于prototype额外的处理 prototype对象会声明一个constructor属性，用来记录临时对象是由哪个函数生成的
hero2.prototype = {
  constructor: hero2,
  ...
}

```