- 冒泡排序

从左边第一个数起，依次与后面的数比较，如果小于则不变；否则互换位置，这样的话，可以保证左边比较小
```javascript
const a = [3, 1, 2]
for(let i = 0; i < a.length - 1; i ++) {
  for(let j = i + 1; j < a.length; j ++) {
    if (a[i] < a[j]) {
      const tmp = a[i]
      a[i] = a[j]
      a[j] = tmp
    }
  }
}
```

- 快速排序
前提: 针对无序数组，三个变量: i = 0; j = arr.length; k = arr[i]
第一步: 数组倒序遍历, 直到找到数组元素比k小的, 与之调换位置, j重新赋值
第二步: 数组正序遍历, 直到找到数组元素比k大的, 与之调换位置, i重新赋值
循环上两步，直至i === j
i 左边部分和右边部分循环上述步骤, 直至无法再循环
```javascript
const a = [4, 1, 5, 2, 10, 6, 98]
function changeValue(arr, left, right) {
  const tmp = arr[left]
  arr[left] = arr[right]
  arr[right] = tmp
}
function qucikSort(leftIndex = 0, rightIndex = a.length - 1) {
  let i = leftIndex;
  let j = rightIndex;
  const k = a[i];
  let direction = 'right'
  while(i !== j) {
    if (direction === 'right') {
      // 什么时候递减，什么时候交换元素
      if (a[j] < k) {
        changeValue(a, i, j)
        direction = 'left'
      } else {
        j--
      }
    } else {
      if (a[i] > k) {
        // 什么时候递增，什么时候交换元素
        changeValue(a, i, j)
        direction = 'right'
      } else {
        i++
      }
    }
  }
  if (leftIndex < i - 1) {
    qucikSort(leftIndex, i - 1)
  }
  if (i + 1 < rightIndex) {
    qucikSort(i + 1, rightIndex)
  }
}
qucikSort()
```