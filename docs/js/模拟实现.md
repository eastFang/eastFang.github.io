### new
```javascript
// 新建一个临时对象
// 临时对象的隐式原型指向函数的原型
// 临时对象的属性被赋值为函数里面的属性
// 返回临时对象
function MyNew(fn, ...args) {
  const tmpObj = {}

  fn.call(tmpObj, ...args)

  tmpObj.__proto__ = fn.prototype

  return tmpObj
}

function Student(name) {
  this.name = name
  this.getName = () => this.name
}

const stu1 = new Student('zdf')
const stu2 = MyNew(Student, 'zdf')
```

### 继承
```javascript
function SuperClass(id) {
  this.id = id
  this.books = ['html', 'css', 'js']
}
SuperClass.prototype.showBooks = function() {
  console.log(this.books)
}
// 子类的原型对象 - 类式继承
// 缺点很明显: 参数无法传递
function SubClass1() {
}
SubClass1.prototype = new SuperClass()

// 构造继承
// 有个缺陷是子类无法继承父类原型上的方法: showBooks
function SubClass2(id) {
  SuperClass.call(this, id)
}

// 组合继承
// 结合了类式继承和构造继承
// 有个缺陷就是父类的构造函数执行了两次
function SubClass3(id) {
  SuperClass.call(this, id)
}
SubClass3.prototype = new SuperClass()
const sub2 = new SubClass3(11)
sub3.showBooks()

// 寄生组合式继承
// 基本上是比较完美的继承方式
function SubClass4(id) {
  SuperClass.call(this, id)
}
SubClass4.prototype = Object.create(SuperClass.prototype)
SubClass4.prototype.constructor = SubClass4
const sub3 = new SubClass4(12)
sub3.showBooks()
```

### 简单工厂模式
```javascript
// 通俗来讲：是一个函数，你是甲方，你给这个函数提需求你要什么，他给你生产什么
const LoginAlert = function(text) {
  this.content = text
}
LoginAlert.prototype.show = function() {
  console.log(this.content)
}
const loginAlert = new LoginAlert('用户名不能多于16个字母或数字')
loginAlert.show()

const LoginConfirm = function(text) {
  this.content = text
}
LoginConfirm.prototype.show = function() {
  console.log(this.content)
}
const loginConfirm = new LoginConfirm('输入框确认')
loginConfirm.show()

// 简单工厂模式
// 暴露出去给别人用的, 使用者无需关心你到底有几个类，只需要说明使用者的需求，该工厂函数会返回相应的实现
function createPop(type, msg) {
  switch(type) {
    case 'alert':
      return new LoginAlert(msg)
    case 'confirm':
      return new LoginConfirm(msg)
    default:
      return null
  }
}

// 工厂方法
function Java() {
  console.log('Java')
}
function Javascript() {
  console.log('Javascript')
}
function Go() {
  console.log('Go')
}
function JobFactory(type) {
  switch(type) {
    case 'Java':
      return new Java()
    case 'Javascript':
      return new Javascript()
    case 'Go':
      return new Go()
    default:
      return null
  }
}

// 为了解决需求扩展，需要改两处的情况
function JobFac(type) {
  if (this instanceof JobFac) {
    return new this[type]()
  }
  return new JobFac(type)
}
JobFac.prototype = {
  Java,
  Javascript,
  Go
}
const jobFac = JobFac('Java')

// 抽象工厂模式
const CheliangFac = function (subType, superType) {
  const superFunc = CheliangFac[superType]
  if (typeof superFunc === 'function') {
    // subType继承superType
    subType.prototype = new superFunc()
    subType.prototype.contructor = subType
    return 
  }

  throw new Error('未创建该抽象类')
}

CheliangFac.Car = function() {
  this.type = 'car'
}

function BMW() {

}
CheliangFac(BMW, 'Car')
const bmw = new BMW()
console.log(bmw.type)

// 建造者模式 重过程，通过组合的方式生成对象

// 原型模式

// 单例模式
// 有别于之前理解的，还包括：单例对象将各个模块的代码井井有条的梳理在一起，例如下面的BS
const BS = {
  Util: {
    method1: () => console.log('method1'),
    method2: () => console.log('method2')
  },
  Tool: {
    method1: () => console.log('method1'),
    method2: () => console.log('method2')
  }
}
BS.Util.method1() // 调用方法

var Conf = (function() { // 只暴露可获取的途径
  var conf = {
    MAX_NUM: 100,
    MIN_NUM: 1,
    COUNT: 100
  }

  return {
    get(name) {
      return conf[name]
    }
  }
})()
console.log(Conf.get('COUNT'))
// 惰性单例
var LazySingle = (function() {
  var _instance = null

  function single() {
    return {
      publicMethod: function() {},
      publicProperty: '1.0'
    }
  }

  return function() {
    if (!_instance) {
      return _instance = single()
    }

    return _instance
  }
})()

const lazySingleInstance1 = LazySingle()
const lazySingleInstance2 = LazySingle()
console.log(lazySingleInstance1 === lazySingleInstance2)

// 外观模式 api polyfill或者简化api调用

// 适配器模式 减少前端代码对后端返回数据结构的依赖, 服务器端数据适配

// 代理模式

// 装饰器模式
```